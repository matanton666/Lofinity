// Node.js script to generate audioConfig.js and backgrounds.js from assets folder
// Usage: node scripts/generateData.js

const fs = require('fs');
const path = require('path');

const ASSETS_DIR = path.join(__dirname, '..', 'assets');
const DATA_DIR = path.join(__dirname, '..', 'src', 'data');

function getFilesRecursive(dir, exts = []) {
    let results = [];
    const list = fs.readdirSync(dir, { withFileTypes: true });
    for (const file of list) {
        const filePath = path.join(dir, file.name);
        if (file.isDirectory()) {
            results = results.concat(getFilesRecursive(filePath, exts));
        } else if (exts.length === 0 || exts.includes(path.extname(file.name).toLowerCase())) {
            results.push(filePath);
        }
    }
    return results;
}

function generateAudioConfig() {
    const musicDir = path.join(ASSETS_DIR, 'music');
    const soundsDir = path.join(ASSETS_DIR, 'sounds');
    const music = {};
    const ambient = {};

    // Music
    if (fs.existsSync(musicDir)) {
        for (const category of fs.readdirSync(musicDir)) {
            const catPath = path.join(musicDir, category);
            if (fs.statSync(catPath).isDirectory()) {
                const files = fs.readdirSync(catPath).filter(f => f.endsWith('.mp3'));
                if (files.length) {
                    music[category] = files.map(f => `assets/music/${category}/${f}`);
                }
            }
        }
    }
    // Ambient
    if (fs.existsSync(soundsDir)) {
        for (const category of fs.readdirSync(soundsDir)) {
            const catPath = path.join(soundsDir, category);
            if (fs.statSync(catPath).isDirectory()) {
                const files = fs.readdirSync(catPath).filter(f => f.endsWith('.mp3'));
                if (files.length) {
                    ambient[category] = files.map(f => `assets/sounds/${category}/${f}`);
                }
            }
        }
    }
    return { music, ambient };
}

function generateBackgrounds() {
    const backgroundsDir = path.join(ASSETS_DIR, 'backgrounds');
    const backgrounds = [];
    if (fs.existsSync(backgroundsDir)) {
        for (const category of fs.readdirSync(backgroundsDir)) {
            const catPath = path.join(backgroundsDir, category);
            if (fs.statSync(catPath).isDirectory()) {
                for (const file of fs.readdirSync(catPath)) {
                    if (file.match(/\.(jpg|jpeg|png|webp)$/i)) {
                        const id = `${category}-${path.parse(file).name.split('-').pop()}`;
                        backgrounds.push({
                            id,
                            url: `assets/backgrounds/${category}/${file}`,
                            label: `${category.charAt(0).toUpperCase() + category.slice(1)} ${path.parse(file).name.split('-').pop()}`
                        });
                    }
                }
            }
        }
    }
    return backgrounds;
}

function writeAudioConfig(config) {
    const content = `// Auto-generated by scripts/generateData.js\nconst audioConfig = ${JSON.stringify(config, null, 4)};\n\nexport default audioConfig;\n`;
    fs.writeFileSync(path.join(DATA_DIR, 'audioConfig.js'), content);
}

function writeBackgrounds(backgrounds) {
    const content = `// Auto-generated by scripts/generateData.js\nconst backgrounds = ${JSON.stringify(backgrounds, null, 4)};\n\nexport default backgrounds;\n`;
    fs.writeFileSync(path.join(DATA_DIR, 'backgrounds.js'), content);
}

function main() {
    if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
    const audioConfig = generateAudioConfig();
    writeAudioConfig(audioConfig);
    const backgrounds = generateBackgrounds();
    writeBackgrounds(backgrounds);
    // Remove presets.js if exists
    const presetsPath = path.join(DATA_DIR, 'presets.js');
    if (fs.existsSync(presetsPath)) fs.unlinkSync(presetsPath);
    console.log('audioConfig.js and backgrounds.js generated. presets.js removed.');
}

main();
